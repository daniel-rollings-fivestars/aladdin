{# [Builder image]
    Download and install poetry under the root user.

    This also installs the basic tools for compiling and building python dependencies.
#}
{# [Builder image]
    Install or copy the component.
#}
{% macro build_component(component, build_info) %}

####################################################################################################
# [builder-{{component}}]
####################################################################################################
FROM {{build_info.builder_image}} AS builder-{{component}}

# Install packages required to build native library components
RUN apt-get update \
 && apt-get -y --no-install-recommends install \
    build-essential
# We intentionally do not clear the lists here, as it's unnecessary for a builder image
# and we may need to install some component-specific components, too.
# The image size here isn't as much of a concern, since none of these build tools will
# end-up in the final built image.

{% if build_info.component_packages(component) %}
# Install any additional packages required by the component
RUN apt-get -y --no-install-recommends install \
    {{" ".join(build_info.component_packages(component))}}

{% endif %}
{#
    We use the eventual image's working directory here because we will likely "poetry install" a component.
    This will install the package in "editable" mode, where it builds the .egg-info directory directly in
    the source directory and creates an .egg-link file in the site-packages directory. This link consists
    of an absolute path pointing at the package directory, which will be the component directory itself.
    We will copy the site-packages directory (containing the .egg-link file) and the component directory
    from the build image into the final image. This means that the working directory here must match the
    one used in the final generated image to preserve the integrity of the .egg-link file. This is also
    crucial to allowing us to mount the source code directory during development for rapid dev and testing.
#}
# Use the final image's working directory
WORKDIR {{build_info.workdir or "/build"}}

# We will copy the contents of this directory during the "collect" phase.
# Ensure that it exists even if no python packages were built or installed.
RUN mkdir -p /root/.local

{% if build_info.component_is_poetry_project(component) %}
{{ install_poetry(component, build_info) }}
####################################################################################################
# [builder-{{component}}] Build python dependencies
####################################################################################################
# Copy the {{component}} component's poetry files into the image
COPY {{component}}/pyproject.toml {{component}}/poetry.lock {{component}}/

# Build the dependencies into /root/.local{% if not build_info.dev %} and then pre-compile them{% endif %}

RUN cd {{component}} \
 && poetry install --no-root {% if not build_info.dev %} --no-dev \
 && python -O -m compileall /root/.local
{% endif %}

{% endif %}

####################################################################################################
# [builder-{{component}}] Get component code
####################################################################################################
COPY {{component}} {{component}}

{% if build_info.component_is_poetry_project(component) %}
####################################################################################################
# [builder-{{component}}] Install component
####################################################################################################
RUN cd {{component}} \
 && poetry install {% if not build_info.dev %} --no-dev \
 && python -O -m compileall .
{% endif %}

{% endif %}
{% endmacro %}

{#
    Download and install the poetry package manager tool and configure pip as well.
#}
{% macro install_poetry(builder_name, build_info) %}
####################################################################################################
# [builder-{{builder_name}}] Install poetry
####################################################################################################
# Note: We prefer installing python packages as --user so that the artifacts are easier
#       to copy out of the builder image into the final image. poetry already installs
#       itself under the user directory (and ironically, we eventually copy the poetry
#       tool into a system directory in the final image).

RUN apt-get update \
 && apt-get -y --no-install-recommends install \
    curl

# Configure pip, mainly to ensure that packages are installed in the user directory.
COPY pip.conf /etc/pip.conf

# Install poetry under the root user's home directory.
# On some images "sh" is aliased to "dash" which does not support "set -o pipefail".
# We use the "exec" form of RUN to delegate this command to bash instead.
# This is all because we have a pipe in this command.
RUN ["/bin/bash", "-c", "set -o pipefail && pip install --upgrade pip && curl -sSL https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py | POETRY_VERSION={{build_info.poetry_version}} python && chmod a+x /root/.poetry/bin/poetry"]
COPY poetry.toml /root/.config/pypoetry/config.toml
ENV PATH=/root/.poetry/bin:$PATH
{% endmacro %}


{# [Builder image]
    Collect the python dependencies and component content into an intermediate builder image
    so that we only need two COPY operations to get all of the component contents into the
    final image, instead of two for each component.
#}
{% macro collect_components(build_info) %}
FROM {{build_info.builder_image}} AS builder-collect

# We will copy the contents of this directory to the final image.
# Ensure that it exists even if no python packages were built or installed.
RUN mkdir -p /root/.local

# Copy built python dependencies
{% for component in build_info.components %}
{% if build_info.component_is_poetry_project(component) %}
COPY --from="builder-{{component}}" /root/.local /root/.local
{% endif -%}

{% endfor %}

# Copy component contents (from the builder images' WORKDIRs)
{% for component in build_info.components %}
COPY --from="builder-{{component}}" {{build_info.workdir or "/build"}}/{{component}} /code/{{component}}
{% endfor %}

{% endmacro %}


{#
    Copy the poetry install from the poetry builder image into a system location and configure
    it for usage by any user on the system.
#}
{% macro add_poetry() %}
####################################################################################################
# Install poetry from builder-poetry
####################################################################################################
# Copy installed poetry packages from the builder image to a system directory in the
# this image. While this isn't strictly how poetry is expected to be installed, it's
# not violating any assumptions. We'll use the XDG_CONFIG_HOME to inform poetry where
# it can read its config from and add the .poetry/bin directory to the PATH so any user
# can use it.
COPY --from="builder-poetry" /root/.poetry /usr/local/share/.poetry

# Configure poetry
COPY --from="builder-poetry" /root/.config/pypoetry /usr/local/etc/pypoetry
ENV XDG_CONFIG_HOME=/usr/local/etc \
    PATH=/usr/local/share/.poetry/bin:$PATH
{% endmacro %}


{#
    Add a user account to the image and switch to it.
#}
{% macro add_user(user_info) %}
# Create the unprivileged user account
RUN groupadd -f {{user_info.group}} \
 && useradd -m -d {{user_info.home}} -g {{user_info.group}} {{user_info.name}} {% if user_info.sudo %} \
 && apt-get update && apt-get -y --no-install-recommends install sudo \
 && rm -rf /var/lib/apt/lists/* \
 && echo >> /etc/sudoers "{{user_info.name}} ALL=(ALL) NOPASSWD: ALL"
{% endif %}

# Switch to the unprivileged user account
USER {{user_info.name}}
{% endmacro %}

{#
    Copy the components' dependencies and artifacts into the final image.
 #}
{% macro add_collected_components(build_info) %}
####################################################################################################
# Add collected components
####################################################################################################
# Copy component dependencies and contents (to minimize layers in final build)
{# COPY --from="builder-collect" --chown={{build_info.user_info.chown}} /root/.local {{build_info.user_info.home}}/.local #}
COPY --from="builder-collect" --chown={{build_info.user_info.chown}} /root/.local /usr/local
COPY --from="builder-collect" --chown={{build_info.user_info.chown}} /code ./
{% endmacro %}
